{"version":3,"sources":["../../../backend/routes/auth/auth.controller.ts","../../../backend/config/envConfig.ts","../../../backend/routes/user/user.model.ts","../../../backend/utils/enums.ts","../../../backend/utils/httpHandlers.ts","../../../backend/utils/serviceResponse.ts","../../../backend/middleware/errorHandler.ts","../../../backend/routes/user/user.schema.ts","../../../backend/utils/email.ts"],"sourcesContent":["import type { Request, Response, NextFunction } from \"express\"\nimport { StatusCodes } from \"http-status-codes\"\nimport jwt from \"jsonwebtoken\"\nimport crypto from \"crypto\"\nimport { env } from \"@/config/envConfig\"\nimport { User } from \"@/routes/user/user.model\"\nimport { ErrorHandler, asyncCatch } from \"@/middleware/errorHandler\"\nimport { createUserSchema, loginUserSchema, forgotPasswordSchema, resetPasswordSchema } from \"@/routes/user/user.schema\"\nimport { sendEmail } from \"@/utils/email\"\n\nconst signToken = (id: any) => {\n    return jwt.sign({ id }, env.JWT_SECRET as any, {\n        expiresIn: env.JWT_EXPIRES_IN as any,\n    })\n}\n\nexport const register = asyncCatch(async (req: Request, res: Response, next: NextFunction) => {\n    // 1) Validate input\n    const validatedData = createUserSchema.parse(req.body);\n\n    // 2) Check if user already exists\n    const existingUser = await User.findOne({ email: validatedData.email })\n    if (existingUser) {\n        return next(new ErrorHandler(\"Email already in use\", StatusCodes.CONFLICT))\n    }\n\n    // 3) Create user\n    const newUser = await User.create(validatedData) as typeof User.prototype\n\n    // 4) Generate JWT\n    const token = signToken((newUser._id as string).toString())\n\n    // 5) Send response\n    res.status(StatusCodes.CREATED).json({\n        status: \"success\",\n        token,\n        data: {\n        user: {\n            id: newUser._id,\n            name: newUser.name,\n            email: newUser.email,\n            role: newUser.role,\n        },\n        },\n    })\n})\n\nexport const login = asyncCatch(async (req: Request, res: Response, next: NextFunction) => {\n    // 1) Validate input\n    const validatedData = loginUserSchema.parse(req.body)\n\n    // 2) Check if user exists & password is correct\n    const user = await User.findOne({ email: validatedData.email }).select(\"+password\") as (typeof User.prototype & { _id: string })\n    if (!user || !(await user.comparePassword(validatedData.password))) {\n        return next(new ErrorHandler(\"Incorrect email or password\", StatusCodes.UNAUTHORIZED))\n    }\n\n    // 3) Generate JWT\n    const token = signToken(user._id.toString())\n\n    // 4) Send response\n    res.status(StatusCodes.OK).json({\n        status: \"success\",\n        token,\n        data: {\n        user: {\n            id: user._id,\n            name: user.name,\n            email: user.email,\n            role: user.role,\n        },\n        },\n    })\n})\n\nexport const getMe = asyncCatch(async (req: Request, res: Response, next: NextFunction) => {\n  res.status(StatusCodes.OK).json({\n    status: \"success\",\n    data: {\n      user: req.user,\n    },\n  })\n})\n\nexport const forgotPassword = asyncCatch(async (req: Request, res: Response, next: NextFunction) => {\n    // 1) Validate input\n    const validatedData = forgotPasswordSchema.parse(req.body)\n\n    // 2) Check if user exists\n    const user = await User.findOne({ email: validatedData.email })\n    if (!user) {\n        return next(new ErrorHandler(\"No user found with that email address\", StatusCodes.NOT_FOUND))\n    }\n\n    // 3) Generate random reset token\n    const resetToken = crypto.randomBytes(32).toString(\"hex\")\n    user.resetPasswordToken = crypto\n        .createHash(\"sha256\")\n        .update(resetToken)\n        .digest(\"hex\")\n    user.resetPasswordExpires = new Date(Date.now() + 60 * 60 * 1000) // 1 hour\n\n    await user.save({ validateBeforeSave: false })\n\n    // 4) Send reset email\n    const resetURL = `${env.CORS_ORIGIN}/reset-password/${resetToken}`\n    const message = `Forgot your password? Submit a PATCH request with your new password to: ${resetURL}.\\nIf you didn't forget your password, please ignore this email!`\n\n    try {\n        await sendEmail({\n            email: user.email,\n            subject: \"Your password reset token (valid for 1 hour)\",\n            message,\n        })\n\n        res.status(StatusCodes.OK).json({\n            status: \"success\",\n            message: \"Token sent to email!\",\n        })\n    } catch (err) {\n        user.resetPasswordToken = undefined\n        user.resetPasswordExpires = undefined\n        await user.save({ validateBeforeSave: false })\n\n        return next(new ErrorHandler(\"There was an error sending the email. Try again later!\", StatusCodes.INTERNAL_SERVER_ERROR))\n    }\n})\n\nexport const resetPassword = asyncCatch(async (req: Request, res: Response, next: NextFunction) => {\n    // 1) Validate input\n    const validatedData = resetPasswordSchema.parse(req.body)\n\n    // 2) Get user based on the token\n    const hashedToken = crypto\n        .createHash(\"sha256\")\n        .update(validatedData.token)\n        .digest(\"hex\")\n\n    const user = await User.findOne({\n        resetPasswordToken: hashedToken,\n        resetPasswordExpires: { $gt: Date.now() },\n    }) as (typeof User.prototype & { _id: string })\n\n    if (!user) {\n        return next(new ErrorHandler(\"Token is invalid or has expired\", StatusCodes.BAD_REQUEST))\n    }\n\n    // 3) Update password\n    user.password = validatedData.password\n    user.resetPasswordToken = undefined\n    user.resetPasswordExpires = undefined\n    await user.save()\n\n    // 4) Log the user in, send JWT\n    const token = signToken(user._id.toString())\n\n    res.status(StatusCodes.OK).json({\n        status: \"success\",\n        token,\n        data: {\n            user: {\n                id: user._id,\n                name: user.name,\n                email: user.email,\n                role: user.role,\n            },\n        },\n    })\n})\n","import dotenv from \"dotenv\";\nimport { cleanEnv, host, num, port, str, testOnly } from \"envalid\";\n\ndotenv.config();\n\nexport const env = cleanEnv(process.env, {\n    NODE_ENV: str({ devDefault: testOnly(\"test\"), choices: [\"development\", \"production\", \"test\"] }),\n    HOST: host({ devDefault: testOnly(\"localhost\") }),\n    PORT: port({ devDefault: testOnly(3000) }),\n    MONGODB_URI: str({ desc: \"MongoDB connection string\" }),\n    JWT_SECRET: str({ desc: \"Secret key for JWT\" }),\n    JWT_EXPIRES_IN: str({ default: \"1d\", desc: \"JWT expiration time\" }),\n    CORS_ORIGIN: str({ devDefault: testOnly(\"http://localhost:3000\") }),\n    COMMON_RATE_LIMIT_MAX_REQUESTS: num({ devDefault: testOnly(1000) }),\n    COMMON_RATE_LIMIT_WINDOW_MS: num({ devDefault: testOnly(1000) }),\n    // Email service configuration\n    // SMTP_HOST: str({ desc: \"SMTP host for email service\" }),\n    // SMTP_PORT: num({ desc: \"SMTP port for email service\" }),\n    // SMTP_USER: str({ desc: \"SMTP username\" }),\n    // SMTP_PASS: str({ desc: \"SMTP password\" }),\n    // SMTP_FROM: str({ desc: \"Email sender address\" }),\n    // RESET_PASSWORD_EXPIRES_IN: str({ default: \"1h\", desc: \"Password reset token expiration time\" }),\n});\n","import mongoose, { type Document, Schema } from \"mongoose\"\nimport { UserRole } from \"@/utils/enums\"\nimport bcrypt from \"bcryptjs\"\n\nexport interface IUser extends Document {\n    name: string\n    email: string\n    password: string\n    role: UserRole\n    createdAt: Date\n    updatedAt: Date\n    complaintsSubmitted: mongoose.Types.ObjectId[]\n    agencyId?: mongoose.Types.ObjectId\n    responses: mongoose.Types.ObjectId[]\n    resetPasswordToken?: string\n    resetPasswordExpires?: Date\n    comparePassword(candidatePassword: string): Promise<boolean>\n}\n\nconst userSchema = new Schema<IUser>(\n    {\n        name: {\n            type: String,\n            required: [true, \"Name is required\"],\n            trim: true,\n        },\n        email: {\n            type: String,\n            required: [true, \"Email is required\"],\n            unique: true,\n            lowercase: true,\n            trim: true,\n            validate: {\n                validator: (v: string) => /^\\w+([.-]?\\w+)*@\\w+([.-]?\\w+)*(\\.\\w{2,3})+$/.test(v),\n                message: \"Please enter a valid email\",\n            },\n        },\n        agencyId: {\n            type: Schema.Types.ObjectId,\n            ref: \"Agency\",\n        },\n        password: {\n            type: String,\n            required: [true, \"Password is required\"],\n            minlength: [8, \"Password must be at least 8 characters\"],\n            select: false,\n        },\n        role: {\n            type: String,\n            enum: Object.values(UserRole),\n            default: UserRole.CITIZEN,\n        },\n        complaintsSubmitted: [\n            {\n                type: Schema.Types.ObjectId,\n                ref: \"Complaint\",\n            },\n        ],\n        responses: [\n            {\n                type: Schema.Types.ObjectId,\n                ref: \"Response\",\n            },\n        ],\n        resetPasswordToken: String,\n        resetPasswordExpires: Date,\n    },\n    {\n        timestamps: true,\n    },\n)\n\n// Hash password before saving\nuserSchema.pre(\"save\", async function (next) {\n    if (!this.isModified(\"password\")) return next()\n\n    try {\n        const salt = await bcrypt.genSalt(10)\n        this.password = await bcrypt.hash(this.password, salt)\n        next()\n    } catch (error: any) {\n        next(error)\n    }\n})\n\n// Method to compare passwords\nuserSchema.methods.comparePassword = async function (candidatePassword: string): Promise<boolean> {\n    return bcrypt.compare(candidatePassword, this.password)\n}\n\nexport const User = mongoose.model<IUser>(\"User\", userSchema)\n","export enum UserRole {\n  CITIZEN = \"CITIZEN\",\n  AGENCY_STAFF = \"AGENCY_STAFF\",\n  ADMIN = \"ADMIN\",\n}\n\nexport enum ComplaintStatus {\n  SUBMITTED = \"SUBMITTED\",\n  UNDER_REVIEW = \"UNDER_REVIEW\",\n  IN_PROGRESS = \"IN_PROGRESS\",\n  RESOLVED = \"RESOLVED\",\n  REJECTED = \"REJECTED\",\n  ESCALATED = \"ESCALATED\",\n}\n","import type { NextFunction, Request, Response } from \"express\";\nimport { StatusCodes } from \"http-status-codes\";\nimport type { ZodError, ZodSchema } from \"zod\";\n\nimport { ServiceResponse } from \"@/utils/serviceResponse\";\n\nexport const ApiResponse = (serviceResponse: ServiceResponse<any>, response: Response) => {\n  return response.status(serviceResponse.statusCode).send(serviceResponse);\n};\n\nexport const validateRequest = (schema: ZodSchema) => (req: Request, res: Response, next: NextFunction) => {\n    try {\n        schema.parse({ body: req.body, query: req.query, params: req.params });\n        next();\n    } catch (err) {\n        const errorMessage = `Invalid input: ${(err as ZodError).errors.map((e) => e.message).join(\", \")}`;\n        const statusCode = StatusCodes.BAD_REQUEST;\n        return ServiceResponse.failure(errorMessage, null, statusCode, res);\n    }\n};\n","import { ApiResponse } from \"@/utils/httpHandlers\";\nimport { Response } from \"express\";\nimport { StatusCodes } from \"http-status-codes\";\nimport { z } from \"zod\";\n\nexport class ServiceResponse<T = null> {\n  readonly success: boolean;\n  readonly message: string;\n  readonly responseObject: T;\n  readonly statusCode: number;\n\n  private constructor(success: boolean, message: string, responseObject: T, statusCode: number) {\n    this.success = success;\n    this.message = message;\n    this.responseObject = responseObject;\n    this.statusCode = statusCode;\n  }\n\n  static success<T>(message: string, responseObject: T, statusCode: number = StatusCodes.OK, res: Response) {\n    const serviceResponse = new ServiceResponse(true, message, responseObject, statusCode);\n    return ApiResponse(serviceResponse, res);\n  }\n\n  static failure<T>(message: string, responseObject: T, statusCode: number = StatusCodes.BAD_REQUEST, res: Response) {\n    const serviceResponse = new ServiceResponse(false, message, responseObject, statusCode);\n    return ApiResponse(serviceResponse, res);\n  }\n}\n\nexport const ServiceResponseSchema = <T extends z.ZodTypeAny>(dataSchema: T) =>\n  z.object({\n    success: z.boolean(),\n    message: z.string(),\n    responseObject: dataSchema.optional(),\n    statusCode: z.number(),\n  });\n","import type { ErrorRequestHandler, NextFunction, Request, RequestHandler, Response } from \"express\";\nimport { env } from \"@/config/envConfig\";\nimport { ServiceResponse } from \"@/utils/serviceResponse\";\n\n//ADD 404 TO NOT FOUND ERROR\nconst unexpectedRequest: RequestHandler = (_req, res, next) => {\n    return next(ErrorHandler.NotFound(\"Resources not found\"));\n};\n\n//ADD ERROR TO REQUEST LOG\nconst addErrorToRequestLog: ErrorRequestHandler = (err, _req, res, next) => {\n    res.locals.err = err;\n    next(err);\n};\n\n//RETURN ERROR TO USER AS JSON\nconst returnErrorToUser: ErrorRequestHandler = (error, _req, res, next) => {\n    const statusCode = error.statusCode || 500;\n    const message = error.message || \"Internal Server Error\";\n    error = { ...error, statusCode, message };\n\n    if(env.NODE_ENV === \"development\") {\n        console.log(error);\n        res.status(error.statusCode).json({\n            success:false,\n            message: error.message,\n            error,\n            stack: error.stack\n        })\n    }\n\n    if(env.NODE_ENV === \"production\"){\n        if(error.name === \"CastError\") {\n            const message = `Resource Not Found. Invalid ${error.path}`;\n            error = new ErrorHandler(message,400);\n        }\n        \n        if(error.name ===\"ValidationError\") {\n            const message = Object.values(error.errors).map((val: any) => val.message).join(\", \");\n            error = new ErrorHandler(message, 400);\n        }\n\n        if(error.name === \"ZodError\"){\n            const message = error.issues.map((issue: any) => {\n                const fieldName = issue.path[0];\n                const fieldNameLower = fieldName.toLowerCase();\n                const messageLower = issue.message.toLowerCase();\n                \n                // If field name is not already part of the message, include both\n                if (!messageLower.includes(fieldNameLower)) {\n                    return `${fieldName}: ${issue.message}`;\n                }\n                return issue.message;\n            }).join(\", \");\n            error = new ErrorHandler(message, 400);\n        }\n\n        if(error.code === 11000){\n            const message = `${Object.keys(error.keyValue)} Already exists in database`;\n            error = new ErrorHandler(message,400);\n        }\n\n        if(error.name === \"JsonWebTokenError\"){\n            const message = \"JSON web token is invalid. Try Again!!!\";\n            error = new ErrorHandler(message,400);\n        }\n\n        if(error.name === \"TokenExipiredError\"){\n            const message = \"JSON web token is Expired. Try Again!!!\";\n            error = new ErrorHandler(message,400);\n        }\n\n        return ServiceResponse.failure(error.message || \"Internal Server Error\", null, error.statusCode, res);\n    }\n}\n\n// HANDLE ERRORS BY ATTACHING STATUS CODE AND MESSAGES\nexport class ErrorHandler extends Error {\n    readonly statusCode: number;\n\n    constructor(message: string, statusCode: number){\n        super(message);\n        this.statusCode = statusCode;\n        Error.captureStackTrace(this, this.constructor);\n    }\n\n    static BadRequest(message: string) {\n        return new ErrorHandler(message, 400);\n    }\n    \n    static NotFound(message: string) {\n        return new ErrorHandler(message, 404);\n    }\n\n    static InternalServerError(message = \"Internal Server Error\") {\n        return new ErrorHandler(message, 500);\n    }\n}\n\n//CATCH ASYNCHRONOUS ERROS\nexport const asyncCatch = (handler: any) => (req: Request,res: Response,next: NextFunction)=>\n                               Promise.resolve( handler(req, res, next) )\n                                       .catch( next );\n\n\nexport default () => [unexpectedRequest, addErrorToRequestLog, returnErrorToUser];\n","import { z } from \"zod\"\nimport { UserRole } from \"@/utils/enums\"\n\nexport const createUserSchema = z.object({\n    name: z.string().min(2, \"Name must be at least 2 characters\"),\n    email: z.string().email(\"Invalid email address\"),\n    password: z.string().min(8, \"Password must be at least 8 characters\"),\n    role: z.nativeEnum(UserRole).optional(),\n})\n\nexport const loginUserSchema = z.object({\n    email: z.string().email(\"Invalid email address\"),\n    password: z.string().min(1, \"Password is required\"),\n})\n\nexport const updateUserSchema = z.object({\n    name: z.string().min(2, \"Name must be at least 2 characters\").optional(),\n    email: z.string().email(\"Invalid email address\").optional(),\n    password: z.string().min(8, \"Password must be at least 8 characters\").optional(),\n    role: z.nativeEnum(UserRole).optional(),\n})\n\nexport const forgotPasswordSchema = z.object({\n    email: z.string().email(\"Invalid email address\"),\n})\n\nexport const resetPasswordSchema = z.object({\n    token: z.string(),\n    password: z.string().min(8, \"Password must be at least 8 characters\"),\n})\n\nexport type CreateUserInput = z.infer<typeof createUserSchema>\nexport type LoginUserInput = z.infer<typeof loginUserSchema>\nexport type UpdateUserInput = z.infer<typeof updateUserSchema>\nexport type ForgotPasswordInput = z.infer<typeof forgotPasswordSchema>\nexport type ResetPasswordInput = z.infer<typeof resetPasswordSchema>\n","import nodemailer from \"nodemailer\"\nimport { env } from \"@/config/envConfig\"\n\ninterface EmailOptions {\n    email: string\n    subject: string\n    message: string\n}\n\nexport const sendEmail = async (options: EmailOptions) => {\n    // 1) Create a transporter\n    const transporter = nodemailer.createTransport({\n        host: env.SMTP_HOST,\n        port: env.SMTP_PORT,\n        auth: {\n            user: env.SMTP_USER,\n            pass: env.SMTP_PASS,\n        },\n    })\n\n    // 2) Define the email options\n    const mailOptions = {\n        from: env.SMTP_FROM,\n        to: options.email,\n        subject: options.subject,\n        text: options.message,\n    }\n\n    // 3) Actually send the email\n    await transporter.sendMail(mailOptions)\n} "],"mappings":"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","names":["import_http_status_codes","dotenv","UserRole","bcrypt","mongoose","import_http_status_codes","import_zod","nodemailer","jwt","crypto"]}